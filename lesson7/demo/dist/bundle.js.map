{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../dist/data/feature-class.js","webpack:///../dist/data/field.js","webpack:///../dist/element/feature.js","webpack:///../dist/element/graphic.js","webpack:///../dist/geometry/geometry.js","webpack:///../dist/geometry/point.js","webpack:///../dist/geometry/polygon.js","webpack:///../dist/geometry/polyline.js","webpack:///../dist/index.js","webpack:///../dist/layer/feature-layer.js","webpack:///../dist/layer/graphic-layer.js","webpack:///../dist/layer/layer.js","webpack:///../dist/map.js","webpack:///../dist/projection/bd09.js","webpack:///../dist/projection/gcj02.js","webpack:///../dist/projection/projection.js","webpack:///../dist/projection/web-mercator.js","webpack:///../dist/renderer/category-renderer.js","webpack:///../dist/renderer/class-renderer.js","webpack:///../dist/renderer/renderer.js","webpack:///../dist/renderer/simple-renderer.js","webpack:///../dist/symbol/symbol.js","webpack:///../dist/util/bound.js","webpack:///../dist/util/color.js","webpack:///./demo.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6C;AACO;AACV;AACM;AACF;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAY;AAC7C,sCAAsC,qDAAK;AAC3C,4CAA4C,wDAAO;AACnD;AACA;AACA,iCAAiC,+DAAY;AAC7C,yCAAyC,2DAAQ;AACjD,4CAA4C,wDAAO;AACnD;AACA;AACA,iCAAiC,+DAAY;AAC7C,wCAAwC,yDAAO;AAC/C,4CAA4C,wDAAO;AACnD;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAqD;AACI;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAW,4CAA4C,gEAAiB;AACvG;AACA;AACA;AACA,+BAA+B,oEAAW;AAC1C;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAyD;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAW;AAC1C;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqD;AACI;AAClD;AACP;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA,yBAAyB;AACzB;AACA,+BAA+B,oEAAW,4CAA4C,gEAAiB,KAAK;AAC5G;AACA,+BAA+B,oEAAW;AAC1C;AACA;AACA;AACA;AACA,6DAA6D,oEAAW,KAAK;AAC7E;AACA,8BAA8B,oEAAW;AACzC;AACA;AACA;AACA;AACA;AACA,mDAAmD,oEAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACsD;AAChB;AACe;AACI;AACzD;AACO,oBAAoB,kDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAK;AAC/B;AACA;AACA,+BAA+B,oEAAW,4CAA4C,gEAAiB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,qBAAqB,wDAAc,0BAA0B,oEAAW;AACxE;AACA;AACA,qBAAqB,wDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;;;AC9ElB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsD;AAChB;AACc;AACK;AACzD;AACO,sBAAsB,kDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,0BAA0B,iDAAK;AAC/B;AACA,+BAA+B,oEAAW,4CAA4C,+DAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,qBAAqB,wDAAc,0BAA0B,oEAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsD;AAChB;AACc;AACK;AACzD;AACO,uBAAuB,kDAAQ;AACtC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0BAA0B,iDAAK;AAC/B;AACA,+BAA+B,oEAAW,4CAA4C,+DAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA,qBAAqB,wDAAc,0BAA0B,oEAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;;;AC7FvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsB;AACe;AACR;AACK;AACA;AACE;AACH;AACG;AACD;AACL;AACQ;AACA;AACE;AACE;AACR;AACC;AACH;AACI;AACO;AACE;AACH;AACb;;;;;;;;;;;;;ACrB7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACyB;AACI;AACI;AACN;AACS;AAC1B;AACO;AAC1C,2BAA2B,4CAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAW;AAC1C;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,2CAA2C,+DAAY;AACvD;AACA,gDAAgD,qDAAK;AACrD;AACA;AACA,mFAAmF,iEAAc;AACjG;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,sCAAsC,yBAAyB;AAC/D;AACA;AACA;AACA,iBAAiB,MAAM,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA,uEAAuE,4DAAa;AACpF;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sCAAsC,wEAAc;AACpD;AACA;AACA,2CAA2C,4EAAgB;AAC3D;AACA;AACA;AACA;AACA,2CAA2C,sEAAa;AACxD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAgC;AACyB;AAClD,2BAA2B,4CAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAW;AAC1C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAyD;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAW,2CAA2C;AACrF;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAqC;AACmB;AACH;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iEAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc,aAAa;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAK;AAChC;AACA,wDAAwD,+EAA+E;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7NA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACgB;AACtB;AAChC;AACO,mBAAmB,sDAAU;AACpC,uBAAuB,sDAAU;AACjC;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA,0BAA0B,sDAAU;AACpC,yBAAyB,4CAAK;AAC9B;AACA;AACA,+BAA+B,sDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAA;AAAA;AAAsC;AACgB;AACtD;AACO,oBAAoB,sDAAU;AACrC,uBAAuB,sDAAU;AACjC;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA,0BAA0B,sDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA,gDAAgD;AAChD,CAAC,gCAAgC;AACjC;AACO;AACP;AACA,yBAAyB,WAAW;AACpC;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAsC;AACI;AAC1C;AACO,0BAA0B,sDAAU;AAC3C;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyF;AACrC;AACd;AAC/B;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAY;AACrC,4CAA4C,gEAAiB;AAC7D,4CAA4C,iDAAK;AACjD,8CAA8C,iDAAK;AACnD;AACA;AACA;AACA;AACA,yBAAyB,+DAAY;AACrC,4CAA4C,+DAAgB;AAC5D,8CAA8C,iDAAK;AACnD;AACA;AACA;AACA;AACA,yBAAyB,+DAAY;AACrC,4CAA4C,+DAAgB;AAC5D,4CAA4C,iDAAK;AACjD,8CAA8C,iDAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyF;AACrC;AACd;AAC/B;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,iBAAiB;AAC7B,uBAAuB,YAAY;AACnC;AACA;AACA,qBAAqB,+DAAY;AACjC,wCAAwC,gEAAiB;AACzD,wCAAwC,iDAAK;AAC7C,0CAA0C,iDAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAY;AACjC,wCAAwC,+DAAgB;AACxD,0CAA0C,iDAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAY;AACjC,wCAAwC,+DAAgB;AACxD,wCAAwC,iDAAK;AAC7C,0CAA0C,iDAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DA;AAAA;AAAO;AACP;;;;;;;;;;;;;ACDA;AAAA;AAAO;AACP;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACsC;AAC/B;AACP;AACA;AACA,qCAAqC;AACrC,qCAAqC;AACrC;AACA;AACO;AACP;AACA,iCAAiC;AACjC;AACA,iDAAiD,cAAc;AAC/D;AACO;AACP,uBAAuB;AACvB;AACO;AACP,uBAAuB;AACvB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qCAAqC;AACrC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAK,UAAU,iDAAK,oBAAoB,iDAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxNA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,EAAE,aAAa,EAAE,aAAa,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAaiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,oBAAoB,yCAAG;AACvB;AACA;AACA,KAAK;;AAEL;AACA;AACA,iCAAiC,kDAAY;AAC7C;AACA,iCAAiC,kDAAY;AAC7C;AACA,6BAA6B,oDAAc;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uD","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./demo.js\");\n","import { Feature } from \"../element/feature\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { Point } from \"../geometry/point\";\r\nimport { Polyline } from \"../geometry/polyline\";\r\nimport { Polygon } from \"../geometry/polygon\";\r\nexport class FeatureClass {\r\n    constructor(type) {\r\n        this._fields = [];\r\n        this._features = [];\r\n        this._type = type;\r\n    }\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    get features() {\r\n        return this._features;\r\n    }\r\n    get fields() {\r\n        return this._fields;\r\n    }\r\n    addFeature(feature) {\r\n        this._features.push(feature);\r\n    }\r\n    removeFeature(feature) {\r\n        const index = this._features.findIndex(item => item === feature);\r\n        index != -1 && this._features.splice(index, 1);\r\n    }\r\n    clearFeatures() {\r\n        this._features = [];\r\n    }\r\n    addField(field) {\r\n        this._fields.push(field);\r\n    }\r\n    removeField(field) {\r\n        const index = this._fields.findIndex(item => item === field);\r\n        index != -1 && this._fields.splice(index, 1);\r\n    }\r\n    clearFields() {\r\n        this._fields = [];\r\n    }\r\n    //TODO: multiple point line polygon is not supported\r\n    loadGeoJSON(data) {\r\n        Array.isArray(data.features) && data.features.forEach(item => {\r\n            switch (item.geometry.type) {\r\n                case \"Point\":\r\n                    //TODO: each feature has one type that is ridiculous, cause geojson is a featurecollection, not a featurelayer.\r\n                    this._type = GeometryType.Point;\r\n                    const point = new Point(item.geometry.coordinates[0], item.geometry.coordinates[1]);\r\n                    this._features.push(new Feature(point, item.properties));\r\n                    break;\r\n                case \"LineString\":\r\n                    this._type = GeometryType.Polyline;\r\n                    const polyline = new Polyline(item.geometry.coordinates);\r\n                    this._features.push(new Feature(polyline, item.properties));\r\n                    break;\r\n                case \"Polygon\":\r\n                    this._type = GeometryType.Polygon;\r\n                    const polygon = new Polygon(item.geometry.coordinates);\r\n                    this._features.push(new Feature(polygon, item.properties));\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n}\r\n","export var FieldType;\r\n(function (FieldType) {\r\n    FieldType[FieldType[\"String\"] = 1] = \"String\";\r\n    FieldType[FieldType[\"Number\"] = 2] = \"Number\";\r\n})(FieldType || (FieldType = {}));\r\nexport class Field {\r\n}\r\n","import { SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\nexport class Feature {\r\n    constructor(geometry, properties, symbol) {\r\n        this.visible = true;\r\n        this._geometry = geometry;\r\n        this._properties = properties;\r\n        this._symbol = symbol;\r\n    }\r\n    get symbol() {\r\n        return this._symbol;\r\n    }\r\n    set symbol(value) {\r\n        this._symbol = value;\r\n    }\r\n    get geometry() {\r\n        return this._geometry;\r\n    }\r\n    get properties() {\r\n        return this._properties;\r\n    }\r\n    get bound() {\r\n        return this._geometry ? this._geometry.bound : null;\r\n    }\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimplePointSymbol()) {\r\n        if (this.visible)\r\n            this._geometry.draw(ctx, projection, extent, (this._symbol || symbol));\r\n    }\r\n    intersect(projection = new WebMercator(), extent = projection.bound) {\r\n        if (this.visible)\r\n            return this._geometry.intersect(projection, extent);\r\n    }\r\n}\r\n","import { WebMercator } from \"../projection/web-mercator\";\r\nexport class Graphic {\r\n    constructor(geometry, symbol) {\r\n        this.visible = true;\r\n        this._geometry = geometry;\r\n        this._symbol = symbol;\r\n    }\r\n    get bound() {\r\n        return this._geometry ? this._geometry.bound : null;\r\n    }\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound) {\r\n        if (this.visible)\r\n            this._geometry.draw(ctx, projection, extent, this._symbol);\r\n    }\r\n}\r\n","import { SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\nexport var CoordinateType;\r\n(function (CoordinateType) {\r\n    CoordinateType[CoordinateType[\"Latlng\"] = 1] = \"Latlng\";\r\n    CoordinateType[CoordinateType[\"Projection\"] = 2] = \"Projection\";\r\n    CoordinateType[CoordinateType[\"Screen\"] = 3] = \"Screen\";\r\n})(CoordinateType || (CoordinateType = {}));\r\nexport var GeometryType;\r\n(function (GeometryType) {\r\n    GeometryType[GeometryType[\"Point\"] = 1] = \"Point\";\r\n    GeometryType[GeometryType[\"Polyline\"] = 2] = \"Polyline\";\r\n    GeometryType[GeometryType[\"Polygon\"] = 3] = \"Polygon\";\r\n})(GeometryType || (GeometryType = {}));\r\nexport class Geometry {\r\n    get bound() {\r\n        return this._bound;\r\n    }\r\n    project(projection) { }\r\n    ;\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimplePointSymbol()) { }\r\n    ;\r\n    intersect(projection = new WebMercator(), extent = projection.bound) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        return extent.intersect(this._bound);\r\n    }\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) { }\r\n    ;\r\n    getBound(projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        return this._bound;\r\n    }\r\n    ;\r\n    distance(geometry, type, ctx, projection = new WebMercator()) {\r\n        const center = this.getCenter(type == CoordinateType.Screen ? CoordinateType.Projection : type, projection);\r\n        const point = geometry.getCenter(type == CoordinateType.Screen ? CoordinateType.Projection : type, projection);\r\n        if (type == CoordinateType.Screen) {\r\n            const matrix = ctx.getTransform();\r\n            const screenX1 = (matrix.a * center[0] + matrix.e), screenY1 = (matrix.d * center[1] + matrix.f);\r\n            const screenX2 = (matrix.a * point[0] + matrix.e), screenY2 = (matrix.d * point[1] + matrix.f);\r\n            return Math.sqrt((screenX2 - screenX1) * (screenX2 - screenX1) + (screenY2 - screenY1) * (screenY2 - screenY1));\r\n        }\r\n        else {\r\n            return Math.sqrt((point[0] - center[0]) * (point[0] - center[0]) + (point[1] - center[1]) * (point[1] - center[1]));\r\n        }\r\n    }\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { Geometry, CoordinateType } from \"./geometry\";\r\nimport { Bound } from \"../util/bound\";\r\nimport { SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n//点\r\nexport class Point extends Geometry {\r\n    constructor(lng, lat) {\r\n        super();\r\n        this._lng = lng;\r\n        this._lat = lat;\r\n    }\r\n    ;\r\n    project(projection) {\r\n        this._projection = projection;\r\n        [this._x, this._y] = this._projection.project([this._lng, this._lat]);\r\n        //TODO: bound tolerance\r\n        this._bound = new Bound(this._x, this._y, this._x, this._y);\r\n        this._projected = true;\r\n    }\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimplePointSymbol()) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._projected)\r\n                this.project(projection);\r\n            if (!extent.intersect(this._bound))\r\n                return;\r\n            const matrix = ctx.getTransform();\r\n            this._screenX = (matrix.a * this._x + matrix.e);\r\n            this._screenY = (matrix.d * this._y + matrix.f);\r\n            this._symbol = symbol;\r\n            this._symbol.draw(ctx, this._screenX, this._screenY);\r\n            /*if (symbol instanceof SimplePointSymbol) {\r\n                ctx.save();\r\n                ctx.strokeStyle = (symbol as SimplePointSymbol).strokeStyle;\r\n                ctx.fillStyle = (symbol as SimplePointSymbol).fillStyle;\r\n                ctx.lineWidth = (symbol as SimplePointSymbol).lineWidth;\r\n                ctx.beginPath(); //Start path\r\n                //keep size\r\n                //地理坐标 转回 屏幕坐标\r\n                ctx.setTransform(1,0,0,1,0,0);\r\n                ctx.arc(this._screenX, this._screenY, (symbol as SimplePointSymbol).radius, 0, Math.PI * 2, true);\r\n                ctx.fill();\r\n                ctx.stroke();\r\n                ctx.restore();\r\n            } else if (symbol instanceof SimpleMarkerSymbol) {\r\n                const marker: SimpleMarkerSymbol = symbol;\r\n                if (!marker.loaded) await marker.load();\r\n                if (marker.icon) {\r\n                    ctx.save();\r\n                    const matrix = (ctx as any).getTransform();\r\n                    //keep size\r\n                    ctx.setTransform(1,0,0,1,0,0);\r\n                    ctx.drawImage(marker.icon, this._screenX + marker.offsetX, this._screenY + marker.offsetY, marker.width, marker.height);\r\n                    ctx.restore();\r\n                }\r\n            } */\r\n        });\r\n    }\r\n    ;\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        if (type === CoordinateType.Latlng) {\r\n            return [this._lng, this._lat];\r\n        }\r\n        else {\r\n            return [this._x, this._y];\r\n        }\r\n    }\r\n}\r\nPoint.RADIUS = 10; //10px\r\n","import { Geometry, CoordinateType } from \"./geometry\";\r\nimport { Bound } from \"../util/bound\";\r\nimport { SimpleFillSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n//面\r\nexport class Polygon extends Geometry {\r\n    constructor(lnglats) {\r\n        super();\r\n        this._lnglats = lnglats;\r\n    }\r\n    ;\r\n    project(projection) {\r\n        this._projection = projection;\r\n        this._coordinates = this._lnglats.map((ring) => ring.map((point) => this._projection.project(point)));\r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        this._coordinates.forEach(ring => {\r\n            ring.forEach(point => {\r\n                xmin = Math.min(xmin, point[0]);\r\n                ymin = Math.min(ymin, point[1]);\r\n                xmax = Math.max(xmax, point[0]);\r\n                ymax = Math.max(ymax, point[1]);\r\n            });\r\n        });\r\n        this._bound = new Bound(xmin, ymin, xmax, ymax);\r\n    }\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimpleFillSymbol()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        if (!extent.intersect(this._bound))\r\n            return;\r\n        const matrix = ctx.getTransform();\r\n        this._screen = this._coordinates.map(ring => {\r\n            return ring.map((point, index) => {\r\n                const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n                return [screenX, screenY];\r\n            });\r\n        });\r\n        symbol.draw(ctx, this._screen);\r\n        /*ctx.save();\r\n        ctx.strokeStyle = (symbol as SimpleFillSymbol).strokeStyle;\r\n        ctx.fillStyle = (symbol as SimpleFillSymbol).fillStyle;\r\n        ctx.lineWidth = (symbol as SimpleFillSymbol).lineWidth;\r\n        //keep lineWidth\r\n        ctx.setTransform(1,0,0,1,0,0);\r\n        //TODO:  exceeding the maximum extent(bound), best way is overlap by extent. find out: maximum is [-PI*R, PI*R]??\r\n        this._screen = [];\r\n        ctx.beginPath();\r\n        this._coordinates.forEach( ring => {\r\n            const temp = [];\r\n            this._screen.push(temp);\r\n            ring.forEach((point: any,index) => {\r\n                const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n                if (index === 0){\r\n                    ctx.moveTo(screenX, screenY);\r\n                } else {\r\n                    ctx.lineTo(screenX, screenY);\r\n                }\r\n                temp.push([screenX, screenY]);\r\n            });\r\n        });\r\n        ctx.closePath();\r\n        ctx.fill(\"evenodd\");\r\n        ctx.stroke();\r\n        ctx.restore();*/\r\n    }\r\n    //from Leaflet\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        let i, j, p1, p2, f, area, x, y, center, points = this._coordinates[0], len = points.length;\r\n        if (!len) {\r\n            return null;\r\n        }\r\n        // polygon centroid algorithm; only uses the first ring if there are multiple\r\n        area = x = y = 0;\r\n        for (i = 0, j = len - 1; i < len; j = i++) {\r\n            p1 = points[i];\r\n            p2 = points[j];\r\n            f = p1[1] * p2[0] - p2[1] * p1[0];\r\n            x += (p1[0] + p2[0]) * f;\r\n            y += (p1[1] + p2[1]) * f;\r\n            area += f * 3;\r\n        }\r\n        if (area === 0) {\r\n            // Polygon is so small that all points are on same pixel.\r\n            center = points[0];\r\n        }\r\n        else {\r\n            center = [x / area, y / area];\r\n        }\r\n        if (type === CoordinateType.Latlng) {\r\n            return projection.unproject(center);\r\n        }\r\n        else {\r\n            return center;\r\n        }\r\n    }\r\n}\r\n","import { Geometry, CoordinateType } from \"./geometry\";\r\nimport { Bound } from \"../util/bound\";\r\nimport { SimpleLineSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n//线\r\nexport class Polyline extends Geometry {\r\n    constructor(lnglats) {\r\n        super();\r\n        this._tolerance = 4; //TOLERANCE + symbol.lineWidth\r\n        this._lnglats = lnglats;\r\n    }\r\n    ;\r\n    project(projection) {\r\n        this._projection = projection;\r\n        this._coordinates = this._lnglats.map((point) => this._projection.project(point));\r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        this._coordinates.forEach(point => {\r\n            xmin = Math.min(xmin, point[0]);\r\n            ymin = Math.min(ymin, point[1]);\r\n            xmax = Math.max(xmax, point[0]);\r\n            ymax = Math.max(ymax, point[1]);\r\n        });\r\n        this._bound = new Bound(xmin, ymin, xmax, ymax);\r\n    }\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimpleLineSymbol()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        if (!extent.intersect(this._bound))\r\n            return;\r\n        this._tolerance = Polyline.TOLERANCE + symbol.lineWidth;\r\n        const matrix = ctx.getTransform();\r\n        this._screen = this._coordinates.map((point, index) => {\r\n            const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n            return [screenX, screenY];\r\n        });\r\n        symbol.draw(ctx, this._screen);\r\n        /* ctx.save();\r\n        ctx.strokeStyle = (symbol as SimpleLineSymbol).strokeStyle;\r\n        ctx.lineWidth = (symbol as SimpleLineSymbol).lineWidth;\r\n        const matrix = (ctx as any).getTransform();\r\n        //keep lineWidth\r\n        ctx.setTransform(1,0,0,1,0,0);\r\n        //TODO:  exceeding the maximum extent(bound), best way is overlap by extent. find out: maximum is [-PI*R, PI*R]??\r\n        ctx.beginPath();\r\n        this._coordinates.forEach( (point: any,index) => {\r\n            const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n            if (index === 0){\r\n                ctx.moveTo(screenX, screenY);\r\n            } else {\r\n                ctx.lineTo(screenX, screenY);\r\n            }\r\n        });\r\n        ctx.stroke();\r\n        ctx.restore(); */\r\n    }\r\n    //from Leaflet\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        let i, halfDist, segDist, dist, p1, p2, ratio, points = this._coordinates, len = points.length;\r\n        if (!len) {\r\n            return null;\r\n        }\r\n        // polyline centroid algorithm; only uses the first ring if there are multiple\r\n        for (i = 0, halfDist = 0; i < len - 1; i++) {\r\n            halfDist += Math.sqrt((points[i + 1][0] - points[i][0]) * (points[i + 1][0] - points[i][0]) + (points[i + 1][1] - points[i][1]) * (points[i + 1][1] - points[i][1])) / 2;\r\n        }\r\n        let center;\r\n        // The line is so small in the current view that all points are on the same pixel.\r\n        if (halfDist === 0) {\r\n            center = points[0];\r\n        }\r\n        for (i = 0, dist = 0; i < len - 1; i++) {\r\n            p1 = points[i];\r\n            p2 = points[i + 1];\r\n            segDist = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\r\n            dist += segDist;\r\n            if (dist > halfDist) {\r\n                ratio = (dist - halfDist) / segDist;\r\n                center = [\r\n                    p2[0] - ratio * (p2[0] - p1[0]),\r\n                    p2[1] - ratio * (p2[1] - p1[1])\r\n                ];\r\n            }\r\n        }\r\n        if (type === CoordinateType.Latlng) {\r\n            return projection.unproject(center);\r\n        }\r\n        else {\r\n            return center;\r\n        }\r\n    }\r\n}\r\nPolyline.TOLERANCE = 4; //screen pixel\r\n","export * from './map';\r\nexport * from './data/feature-class';\r\nexport * from './data/field';\r\nexport * from './element/graphic';\r\nexport * from './element/feature';\r\nexport * from './geometry/geometry';\r\nexport * from './geometry/point';\r\nexport * from './geometry/polyline';\r\nexport * from './geometry/polygon';\r\nexport * from './layer/layer';\r\nexport * from './layer/graphic-layer';\r\nexport * from './layer/feature-layer';\r\nexport * from './projection/projection';\r\nexport * from './projection/web-mercator';\r\nexport * from './projection/bd09';\r\nexport * from './projection/gcj02';\r\nexport * from './symbol/symbol';\r\nexport * from './renderer/renderer';\r\nexport * from './renderer/simple-renderer';\r\nexport * from './renderer/category-renderer';\r\nexport * from './renderer/class-renderer';\r\nexport * from './util/bound';\r\n","import { Layer } from \"./layer\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\nimport { SimpleRenderer } from \"../renderer/simple-renderer\";\r\nimport { CategoryRenderer } from \"../renderer/category-renderer\";\r\nimport { ClassRenderer } from \"../renderer/class-renderer\";\r\nimport { GeometryType, CoordinateType } from \"../geometry/geometry\";\r\nimport { Point } from \"../geometry/point\";\r\nimport { ClusterSymbol } from \"../symbol/symbol\";\r\nexport class FeatureLayer extends Layer {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._zoom = [3, 20];\r\n        //是否聚合\r\n        this.cluster = false;\r\n    }\r\n    get featureClass() {\r\n        return this._featureClass;\r\n    }\r\n    set featureClass(value) {\r\n        this._featureClass = value;\r\n    }\r\n    set renderer(value) {\r\n        this._renderer = value;\r\n    }\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) {\r\n        /* if (this.visible && this._zoom[0] <= zoom && this._zoom[1] >= zoom) {\r\n            this._featureClass.features.forEach( (feature: Feature) => {\r\n                feature.draw(ctx, projection, extent, this._getSymbol(feature));\r\n            });\r\n        } */\r\n        if (this.visible && this._zoom[0] <= zoom && this._zoom[1] >= zoom) {\r\n            const features = this._featureClass.features.filter((feature) => feature.intersect(projection, extent));\r\n            if (this._featureClass.type == GeometryType.Point && this.cluster) {\r\n                const cluster = features.reduce((acc, cur) => {\r\n                    if (cur.geometry instanceof Point) {\r\n                        const point = cur.geometry;\r\n                        const item = acc.find((item) => {\r\n                            const distance = point.distance(item.feature.geometry, CoordinateType.Screen, ctx, projection);\r\n                            return distance <= 50;\r\n                        });\r\n                        if (item) {\r\n                            item.count += 1;\r\n                        }\r\n                        else {\r\n                            acc.push({ feature: cur, count: 1 });\r\n                        }\r\n                        return acc;\r\n                    }\r\n                }, []); // {feature, count}\r\n                cluster.forEach((item) => {\r\n                    if (item.count == 1) {\r\n                        item.feature.draw(ctx, projection, extent, this._getSymbol(item.feature));\r\n                    }\r\n                    else {\r\n                        item.feature.draw(ctx, projection, extent, new ClusterSymbol(item.count));\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                features.forEach((feature) => {\r\n                    feature.draw(ctx, projection, extent, this._getSymbol(feature));\r\n                });\r\n            }\r\n        }\r\n    }\r\n    _getSymbol(feature) {\r\n        if (this._renderer instanceof SimpleRenderer) {\r\n            return this._renderer.symbol;\r\n        }\r\n        else if (this._renderer instanceof CategoryRenderer) {\r\n            const renderer = this._renderer;\r\n            const item = renderer.items.find(item => item.value == feature.properties[renderer.field.name]);\r\n            return item.symbol;\r\n        }\r\n        else if (this._renderer instanceof ClassRenderer) {\r\n            const renderer = this._renderer;\r\n            const item = renderer.items.find(item => item.low <= feature.properties[renderer.field.name] && item.high >= feature.properties[renderer.field.name]);\r\n            return item.symbol;\r\n        }\r\n    }\r\n}\r\n","import { Layer } from \"./layer\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\nexport class GraphicLayer extends Layer {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._graphics = [];\r\n    }\r\n    add(graphic) {\r\n        this._graphics.push(graphic);\r\n    }\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound) {\r\n        if (this.visible) {\r\n            this._graphics.forEach((graphic) => {\r\n                graphic.draw(ctx, projection, extent);\r\n            });\r\n        }\r\n    }\r\n}\r\n","import { WebMercator } from \"../projection/web-mercator\";\r\nexport class Layer {\r\n    constructor() {\r\n        this._visible = true;\r\n    }\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    set visible(value) {\r\n        this._visible = value;\r\n    }\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) { }\r\n    ;\r\n}\r\n","import { Bound } from \"./util/bound\";\r\nimport { WebMercator } from \"./projection/web-mercator\";\r\nimport { GraphicLayer } from \"./layer/graphic-layer\";\r\nexport class Map {\r\n    constructor(id) {\r\n        this._drag = {\r\n            flag: false,\r\n            start: {\r\n                x: 0,\r\n                y: 0\r\n            },\r\n            end: {\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        };\r\n        //private _geometries: Geometry[] = [];\r\n        this._defaultGraphicLayer = new GraphicLayer();\r\n        this._layers = [];\r\n        //地图缩放等级\r\n        this._zoom = 1;\r\n        //地图视图中心\r\n        this._center = [0, 0];\r\n        //地图事件的handlers\r\n        this._events = {\r\n            \"move\": [],\r\n            \"extent\": [] //视图范围更新时，当前关注该事件\r\n        };\r\n        this._container = id instanceof HTMLDivElement ? id : document.getElementById(id);\r\n        //create canvas\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.style.cssText = \"position: absolute; height: 100%; width: 100%; z-index: 100\";\r\n        this._canvas.width = this._container.clientWidth;\r\n        this._canvas.height = this._container.clientHeight;\r\n        this._container.appendChild(this._canvas);\r\n        this._ctx = this._canvas.getContext(\"2d\");\r\n        this._onDoubleClick = this._onDoubleClick.bind(this);\r\n        this._onMouseDown = this._onMouseDown.bind(this);\r\n        this._onMouseMove = this._onMouseMove.bind(this);\r\n        this._onMouseUp = this._onMouseUp.bind(this);\r\n        this._onWheel = this._onWheel.bind(this);\r\n        this._canvas.addEventListener(\"dblclick\", this._onDoubleClick);\r\n        this._canvas.addEventListener(\"mousedown\", this._onMouseDown);\r\n        this._canvas.addEventListener(\"mousemove\", this._onMouseMove);\r\n        this._canvas.addEventListener(\"mouseup\", this._onMouseUp);\r\n        this._canvas.addEventListener(\"wheel\", this._onWheel);\r\n        //初始化\r\n        this._projection = new WebMercator();\r\n        this.setView([0, 0], 10);\r\n        this._onResize = this._onResize.bind(this);\r\n        window.addEventListener(\"resize\", this._onResize);\r\n    }\r\n    get projection() {\r\n        return this._projection;\r\n    }\r\n    //地图事件注册监听\r\n    //TODO: need to off\r\n    on(event, handler) {\r\n        this._events[event].push(handler);\r\n    }\r\n    //设置投影\r\n    setProjection(projection) {\r\n        this._projection = projection;\r\n        //const bound: Bound = this._projection.bound;\r\n        //this._ctx.setTransform(256 * Math.pow(2, this._zoom) / (bound.xmax - bound.xmin) * bound.xscale , 0, 0, 256 * Math.pow(2, this._zoom) / (bound.ymax - bound.ymin) * bound.yscale, this._canvas.width / 2, this._canvas.height / 2);\r\n        //center为经纬度，转化为平面坐标\r\n        const origin = this._projection.project(this._center);\r\n        const bound = this._projection.bound;\r\n        //已知：地理坐标origin，转换后屏幕坐标 即canvas的中心 [this._canvas.width / 2, this._canvas.height / 2]\r\n        //求：平面坐标转换矩阵=Map初始矩阵:  地理坐标——屏幕坐标\r\n        //解法如下：\r\n        const a = 256 * Math.pow(2, this._zoom) / (bound.xmax - bound.xmin) * bound.xscale;\r\n        const d = 256 * Math.pow(2, this._zoom) / (bound.ymax - bound.ymin) * bound.yscale;\r\n        const e = this._canvas.width / 2 - a * origin[0];\r\n        const f = this._canvas.height / 2 - d * origin[1];\r\n        this._ctx.setTransform(a, 0, 0, d, e, f);\r\n    }\r\n    //设置视图级别及视图中心\r\n    setView(center = [0, 0], zoom = 3) {\r\n        this._center = center;\r\n        this._zoom = Math.max(3, Math.min(20, zoom));\r\n        //center为经纬度，转化为平面坐标\r\n        const origin = this._projection.project(center);\r\n        const bound = this._projection.bound;\r\n        //已知：地理坐标origin，转换后屏幕坐标 即canvas的中心 [this._canvas.width / 2, this._canvas.height / 2]\r\n        //求：平面坐标转换矩阵=Map初始矩阵:  地理坐标——屏幕坐标\r\n        //解法如下：\r\n        const a = 256 * Math.pow(2, this._zoom) / (bound.xmax - bound.xmin) * bound.xscale;\r\n        const d = 256 * Math.pow(2, this._zoom) / (bound.ymax - bound.ymin) * bound.yscale;\r\n        const e = this._canvas.width / 2 - a * origin[0];\r\n        const f = this._canvas.height / 2 - d * origin[1];\r\n        this._ctx.setTransform(a, 0, 0, d, e, f);\r\n        this.redraw();\r\n    }\r\n    //TODO: manage geometry by layer\r\n    /* addGeometry(geometry: Geometry) {\r\n        geometry.draw(this._ctx);\r\n        this._geometries.push(geometry);\r\n    } */\r\n    addLayer(layer) {\r\n        this._layers.push(layer);\r\n        layer.draw(this._ctx, this._projection, this._extent);\r\n    }\r\n    //shortcut\r\n    addGraphic(graphic) {\r\n        this._defaultGraphicLayer.add(graphic);\r\n        graphic.draw(this._ctx, this._projection, this._extent);\r\n    }\r\n    //更新地图视图范围以及中心点\r\n    updateExtent() {\r\n        const matrix = this._ctx.getTransform();\r\n        const x1 = (0 - matrix.e) / matrix.a, y1 = (0 - matrix.f) / matrix.d, x2 = (this._canvas.width - matrix.e) / matrix.a, y2 = (this._canvas.height - matrix.f) / matrix.d;\r\n        this._extent = new Bound(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2));\r\n        this._center = this._projection.unproject([(x1 + x2) / 2, (y1 + y2) / 2]);\r\n        this._events.extent.forEach(handler => handler({ extent: this._extent, center: this._center, zoom: this._zoom, matrix: matrix }));\r\n    }\r\n    redraw() {\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n        this.updateExtent();\r\n        //this._geometries.forEach(geometry => geometry.draw(this._ctx));\r\n        this._defaultGraphicLayer.draw(this._ctx, this._projection, this._extent);\r\n        this._layers.forEach(layer => {\r\n            layer.draw(this._ctx, this._projection, this._extent);\r\n        });\r\n    }\r\n    clear() {\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n    }\r\n    _onResize(event) {\r\n        this._canvas.width = this._container.clientWidth;\r\n        this._canvas.height = this._container.clientHeight;\r\n        this.setView(this._center, this._zoom);\r\n    }\r\n    _onDoubleClick(event) {\r\n        if (this._zoom >= 20)\r\n            return;\r\n        const scale = 2;\r\n        this._zoom += 1;\r\n        const matrix = this._ctx.getTransform();\r\n        const a1 = matrix.a, e1 = matrix.e, x1 = event.x, x2 = x1; //放大到中心点 x2 = this._canvas.width / 2\r\n        const e = (x2 - scale * (x1 - e1) - e1) / a1;\r\n        const d1 = matrix.d, f1 = matrix.f, y1 = event.y, y2 = y1; //放大到中心点 y2 = this._canvas.height / 2\r\n        const f = (y2 - scale * (y1 - f1) - f1) / d1;\r\n        this._ctx.transform(scale, 0, 0, scale, e, f);\r\n        this.redraw();\r\n    }\r\n    _onMouseDown(event) {\r\n        this._drag.flag = true;\r\n        this._drag.start.x = event.x;\r\n        this._drag.start.y = event.y;\r\n    }\r\n    _onMouseMove(event) {\r\n    }\r\n    _onMouseUp(event) {\r\n        if (this._drag.flag) {\r\n            this._drag.end.x = event.x;\r\n            this._drag.end.y = event.y;\r\n            const matrix = this._ctx.getTransform();\r\n            this._ctx.translate((this._drag.end.x - this._drag.start.x) / matrix.a, (this._drag.end.y - this._drag.start.y) / matrix.d);\r\n            this.redraw();\r\n        }\r\n        this._drag.flag = false;\r\n    }\r\n    _onWheel(event) {\r\n        event.preventDefault();\r\n        const sensitivity = 5;\r\n        if (Math.abs(event.deltaY) <= sensitivity)\r\n            return;\r\n        //const sensitivity = 100;\r\n        //const delta = event.deltaY / sensitivity;\r\n        const delta = event.deltaY < 0 ? -1 : 1;\r\n        let scale = 1;\r\n        if (delta < 0) {\r\n            // 放大\r\n            scale *= delta * -2;\r\n        }\r\n        else {\r\n            // 缩小\r\n            scale /= delta * 2;\r\n        }\r\n        let zoom = Math.round(Math.log(scale));\r\n        if (zoom > 0) {\r\n            // 放大\r\n            zoom = this._zoom + zoom >= 20 ? 20 - this._zoom : zoom;\r\n        }\r\n        else if (zoom < 0) {\r\n            // 缩小\r\n            zoom = this._zoom + zoom <= 3 ? 3 - this._zoom : zoom;\r\n        }\r\n        if (zoom == 0)\r\n            return;\r\n        this._zoom += zoom;\r\n        scale = Math.pow(2, zoom);\r\n        //交互表现为 鼠标当前位置 屏幕坐标不变 进行缩放 即x2 = x1，y2=y1\r\n        //其它设定：变换前矩阵(a1,0,0,d1,e1,f1)   变换矩阵(a,0,0,d,e,f)  变换后矩阵(a2,0,0,d2,e2,f2) \r\n        //scale已通过滚轮变化，换算得到，且a=d=scale，求e和f\r\n        //1.将原屏幕坐标 x1 转成 地理坐标 x0 = (x1 - e1) / a1 \r\n        //2.地理坐标x0 转成 现屏幕坐标x2  a2 * x0 + e2 = x2 e2 = x2 - a2 * x0 代入1式 e2 = x2 - a2 * (x1 - e1) / a1\r\n        //3.已知scale = a2 / a1 故 e2 = x2 - scale * (x1 - e1)\r\n        //4.另矩阵变换 a1 * e + e1 = e2\r\n        //5.联立3和4 求得 e = (x2 - scale * (x1 - e1) - e1) / a1\r\n        const matrix = this._ctx.getTransform();\r\n        const a1 = matrix.a, e1 = matrix.e, x1 = event.x, x2 = x1; //放大到中心点 x2 = this._canvas.width / 2\r\n        const e = (x2 - scale * (x1 - e1) - e1) / a1;\r\n        const d1 = matrix.d, f1 = matrix.f, y1 = event.y, y2 = y1; //放大到中心点 y2 = this._canvas.height / 2\r\n        const f = (y2 - scale * (y1 - f1) - f1) / d1;\r\n        this._ctx.transform(scale, 0, 0, scale, e, f);\r\n        this.redraw();\r\n    }\r\n    destroy() {\r\n        window.removeEventListener(\"resize\", this._onResize);\r\n        this._canvas.removeEventListener(\"dblclick\", this._onDoubleClick);\r\n        this._canvas.removeEventListener(\"mousedown\", this._onMouseDown);\r\n        this._canvas.removeEventListener(\"mousemove\", this._onMouseMove);\r\n        this._canvas.removeEventListener(\"mouseup\", this._onMouseUp);\r\n        this._canvas.removeEventListener(\"wheel\", this._onWheel);\r\n    }\r\n}\r\n","import { Bound } from \"../util/bound\";\r\nimport { LatLngType, Projection } from \"./projection\";\r\nimport { GCJ02 } from \"./gcj02\";\r\n//just for china\r\nexport class BD09 extends Projection {\r\n    constructor(type = LatLngType.GPS) {\r\n        super();\r\n        this._type = type;\r\n    }\r\n    //投影后的平面坐标范围\r\n    get bound() {\r\n        return new Bound(-BD09.TOTAL_PIXELS / 2, BD09.TOTAL_PIXELS / 2, BD09.TOTAL_PIXELS / 2, -BD09.TOTAL_PIXELS / 2);\r\n    }\r\n    //经纬度转平面坐标\r\n    project([lng, lat]) {\r\n        //from leaflet & wiki\r\n        if (this._type == LatLngType.GPS) {\r\n            [lng, lat] = GCJ02.wgs84togcj02(lng, lat);\r\n            [lng, lat] = BD09.gcj02tobd09(lng, lat);\r\n        }\r\n        else if (this._type == LatLngType.GCJ02) {\r\n            [lng, lat] = BD09.gcj02tobd09(lng, lat);\r\n        }\r\n        const projection = new BMap.MercatorProjection();\r\n        const pixel = projection.lngLatToPoint(new BMap.Point(lng, lat));\r\n        return [pixel.x, pixel.y];\r\n        /*const d = Math.PI / 180, sin = Math.sin(lat * d);\r\n        return [WebMercator.R * lng * d,  WebMercator.R * Math.log((1 + sin) / (1 - sin)) / 2];*/\r\n    }\r\n    //平面坐标转经纬度\r\n    unproject([x, y]) {\r\n        const projection = new BMap.MercatorProjection();\r\n        const point = projection.pointToLngLat(new BMap.Pixel(x, y));\r\n        return [point.lng, point.lat];\r\n        /*const d = 180 / Math.PI;\r\n        return  [x * d / WebMercator.R, (2 * Math.atan(Math.exp(y / WebMercator.R)) - (Math.PI / 2)) * d];*/\r\n    }\r\n    //from https://github.com/wandergis/coordtransform\r\n    /**\r\n     * 百度坐标系 (BD-09) 与 火星坐标系 (GCJ-02) 的转换\r\n     * 即 百度 转 谷歌、高德\r\n     * @param bd_lng\r\n     * @param bd_lat\r\n     * @returns {*[]}\r\n     */\r\n    static bd09togcj02(bd_lng, bd_lat) {\r\n        var x = bd_lng - 0.0065;\r\n        var y = bd_lat - 0.006;\r\n        var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * Math.PI * 3000.0 / 180.0);\r\n        var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * Math.PI * 3000.0 / 180.0);\r\n        var gg_lng = z * Math.cos(theta);\r\n        var gg_lat = z * Math.sin(theta);\r\n        return [gg_lng, gg_lat];\r\n    }\r\n    ;\r\n    /**\r\n     * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换\r\n     * 即 谷歌、高德 转 百度\r\n     * @param lng\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\r\n    static gcj02tobd09(lng, lat) {\r\n        var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * Math.PI * 3000.0 / 180.0);\r\n        var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * Math.PI * 3000.0 / 180.0);\r\n        var bd_lng = z * Math.cos(theta) + 0.0065;\r\n        var bd_lat = z * Math.sin(theta) + 0.006;\r\n        return [bd_lng, bd_lat];\r\n    }\r\n    ;\r\n}\r\n//百度平面坐标系的坐标原点与百度瓦片坐标原点相同，以瓦片等级18级为基准，规定18级时百度平面坐标的一个单位等于屏幕上的一个像素\r\nBD09.TOTAL_PIXELS = 256 * Math.pow(2, 18);\r\n","import { Bound } from \"../util/bound\";\r\nimport { LatLngType, Projection } from \"./projection\";\r\n//just for china\r\nexport class GCJ02 extends Projection {\r\n    constructor(type = LatLngType.GPS) {\r\n        super();\r\n        this._type = type;\r\n    }\r\n    //投影后的平面坐标范围\r\n    get bound() {\r\n        return new Bound(-Math.PI * GCJ02.R, Math.PI * GCJ02.R, Math.PI * GCJ02.R, -Math.PI * GCJ02.R);\r\n    }\r\n    //经纬度转平面坐标\r\n    project([lng, lat]) {\r\n        if (this._type == LatLngType.GPS) {\r\n            [lng, lat] = GCJ02.wgs84togcj02(lng, lat);\r\n        }\r\n        //from leaflet & wiki\r\n        const d = Math.PI / 180, sin = Math.sin(lat * d);\r\n        return [GCJ02.R * lng * d, GCJ02.R * Math.log((1 + sin) / (1 - sin)) / 2];\r\n    }\r\n    //平面坐标转经纬度\r\n    unproject([x, y]) {\r\n        const d = 180 / Math.PI;\r\n        return [x * d / GCJ02.R, (2 * Math.atan(Math.exp(y / GCJ02.R)) - (Math.PI / 2)) * d];\r\n    }\r\n    //from https://github.com/wandergis/coordtransform\r\n    /**\r\n     * WGS-84 转 GCJ-02\r\n     * @param lng\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\r\n    static wgs84togcj02(lng, lat) {\r\n        var dlat = this._transformlat(lng - 105.0, lat - 35.0);\r\n        var dlng = this._transformlng(lng - 105.0, lat - 35.0);\r\n        var radlat = lat / 180.0 * Math.PI;\r\n        var magic = Math.sin(radlat);\r\n        magic = 1 - GCJ02.ee * magic * magic;\r\n        var sqrtmagic = Math.sqrt(magic);\r\n        dlat = (dlat * 180.0) / ((GCJ02.R * (1 - GCJ02.ee)) / (magic * sqrtmagic) * Math.PI);\r\n        dlng = (dlng * 180.0) / (GCJ02.R / sqrtmagic * Math.cos(radlat) * Math.PI);\r\n        var mglat = lat + dlat;\r\n        var mglng = lng + dlng;\r\n        return [mglng, mglat];\r\n    }\r\n    ;\r\n    /**\r\n     * GCJ-02 转换为 WGS-84\r\n     * @param lng\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\r\n    static gcj02towgs84(lng, lat) {\r\n        var dlat = this._transformlat(lng - 105.0, lat - 35.0);\r\n        var dlng = this._transformlng(lng - 105.0, lat - 35.0);\r\n        var radlat = lat / 180.0 * Math.PI;\r\n        var magic = Math.sin(radlat);\r\n        magic = 1 - GCJ02.ee * magic * magic;\r\n        var sqrtmagic = Math.sqrt(magic);\r\n        dlat = (dlat * 180.0) / ((GCJ02.R * (1 - GCJ02.ee)) / (magic * sqrtmagic) * Math.PI);\r\n        dlng = (dlng * 180.0) / (GCJ02.R / sqrtmagic * Math.cos(radlat) * Math.PI);\r\n        var mglat = lat + dlat;\r\n        var mglng = lng + dlng;\r\n        return [lng * 2 - mglng, lat * 2 - mglat];\r\n    }\r\n    ;\r\n    static _transformlat(lng, lat) {\r\n        var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));\r\n        ret += (20.0 * Math.sin(6.0 * lng * Math.PI) + 20.0 * Math.sin(2.0 * lng * Math.PI)) * 2.0 / 3.0;\r\n        ret += (20.0 * Math.sin(lat * Math.PI) + 40.0 * Math.sin(lat / 3.0 * Math.PI)) * 2.0 / 3.0;\r\n        ret += (160.0 * Math.sin(lat / 12.0 * Math.PI) + 320 * Math.sin(lat * Math.PI / 30.0)) * 2.0 / 3.0;\r\n        return ret;\r\n    }\r\n    ;\r\n    static _transformlng(lng, lat) {\r\n        var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));\r\n        ret += (20.0 * Math.sin(6.0 * lng * Math.PI) + 20.0 * Math.sin(2.0 * lng * Math.PI)) * 2.0 / 3.0;\r\n        ret += (20.0 * Math.sin(lng * Math.PI) + 40.0 * Math.sin(lng / 3.0 * Math.PI)) * 2.0 / 3.0;\r\n        ret += (150.0 * Math.sin(lng / 12.0 * Math.PI) + 300.0 * Math.sin(lng / 30.0 * Math.PI)) * 2.0 / 3.0;\r\n        return ret;\r\n    }\r\n    ;\r\n    //此判断欠妥，暂不采用！\r\n    /**\r\n     * 判断是否在国内，不在国内则不做偏移\r\n     * @param lng\r\n     * @param lat\r\n     * @returns {boolean}\r\n     */\r\n    static out_of_china(lng, lat) {\r\n        // 纬度 3.86~53.55, 经度 73.66~135.05\r\n        return !(lng > 73.66 && lng < 135.05 && lat > 3.86 && lat < 53.55);\r\n    }\r\n    ;\r\n}\r\nGCJ02.R = 6378137.0;\r\nGCJ02.ee = 0.00669342162296594323;\r\n","export var LatLngType;\r\n(function (LatLngType) {\r\n    LatLngType[LatLngType[\"GPS\"] = 1] = \"GPS\";\r\n    LatLngType[LatLngType[\"GCJ02\"] = 2] = \"GCJ02\";\r\n    LatLngType[LatLngType[\"BD09\"] = 3] = \"BD09\"; //Just For China, BaiduMap\r\n})(LatLngType || (LatLngType = {}));\r\n//TODO: only support web mecator\r\nexport class Projection {\r\n    //经纬度转平面坐标\r\n    project([lng, lat]) { return []; }\r\n    ;\r\n    //平面坐标转经纬度\r\n    unproject([x, y]) { return []; }\r\n    ;\r\n    //投影后的平面坐标范围\r\n    get bound() { return null; }\r\n    ;\r\n}\r\n","import { Bound } from \"../util/bound\";\r\nimport { Projection } from \"./projection\";\r\n//球体墨卡托\r\nexport class WebMercator extends Projection {\r\n    //投影后的平面坐标范围\r\n    get bound() {\r\n        return new Bound(-Math.PI * WebMercator.R, Math.PI * WebMercator.R, Math.PI * WebMercator.R, -Math.PI * WebMercator.R);\r\n    }\r\n    //经纬度转平面坐标\r\n    project([lng, lat]) {\r\n        //from leaflet & wiki\r\n        const d = Math.PI / 180, sin = Math.sin(lat * d);\r\n        return [WebMercator.R * lng * d, WebMercator.R * Math.log((1 + sin) / (1 - sin)) / 2];\r\n    }\r\n    //平面坐标转经纬度\r\n    unproject([x, y]) {\r\n        const d = 180 / Math.PI;\r\n        return [x * d / WebMercator.R, (2 * Math.atan(Math.exp(y / WebMercator.R)) - (Math.PI / 2)) * d];\r\n    }\r\n}\r\nWebMercator.R = 6378137;\r\n","import { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { Color } from \"../util/color\";\r\nexport class CategoryRendererItem {\r\n    constructor() {\r\n        this.count = 1;\r\n    }\r\n}\r\n//分类渲染\r\nexport class CategoryRenderer {\r\n    constructor() {\r\n        this._items = [];\r\n    }\r\n    get field() {\r\n        return this._field;\r\n    }\r\n    get items() {\r\n        return this._items;\r\n    }\r\n    generate(featureClass, field) {\r\n        this._field = field;\r\n        this._items = [];\r\n        featureClass.features.map(feature => feature.properties[field.name]).forEach((value) => {\r\n            const item = this._items.find(item => item.value == value);\r\n            if (item) {\r\n                item.count += 1;\r\n            }\r\n            else {\r\n                const item = new CategoryRendererItem();\r\n                switch (featureClass.type) {\r\n                    case GeometryType.Point:\r\n                        const symbol1 = new SimplePointSymbol();\r\n                        symbol1.fillStyle = Color.random().toString();\r\n                        symbol1.strokeStyle = Color.random().toString();\r\n                        item.symbol = symbol1;\r\n                        item.value = value;\r\n                        this._items.push(item);\r\n                        break;\r\n                    case GeometryType.Polyline:\r\n                        const symbol2 = new SimpleLineSymbol();\r\n                        symbol2.strokeStyle = Color.random().toString();\r\n                        item.symbol = symbol2;\r\n                        item.value = value;\r\n                        this._items.push(item);\r\n                        break;\r\n                    case GeometryType.Polygon:\r\n                        const symbol3 = new SimpleFillSymbol();\r\n                        symbol3.fillStyle = Color.random().toString();\r\n                        symbol3.strokeStyle = Color.random().toString();\r\n                        item.symbol = symbol3;\r\n                        item.value = value;\r\n                        this._items.push(item);\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n","import { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { Color } from \"../util/color\";\r\nexport class ClassRendererItem {\r\n}\r\n//分级渲染\r\nexport class ClassRenderer {\r\n    constructor() {\r\n        this._items = [];\r\n    }\r\n    get field() {\r\n        return this._field;\r\n    }\r\n    get items() {\r\n        return this._items;\r\n    }\r\n    //均分\r\n    generate(featureClass, field, breaks) {\r\n        this._field = field;\r\n        this._items = [];\r\n        const stat = featureClass.features.map(feature => feature.properties[field.name]).reduce((stat, cur) => {\r\n            stat.max = Math.max(cur, stat.max);\r\n            stat.min = Math.min(cur, stat.max);\r\n            return stat;\r\n        }, { min: 0, max: 0 });\r\n        for (let i = 0; i < breaks; i++) {\r\n            const item = new ClassRendererItem();\r\n            switch (featureClass.type) {\r\n                case GeometryType.Point:\r\n                    const symbol1 = new SimplePointSymbol();\r\n                    symbol1.fillStyle = Color.random().toString();\r\n                    symbol1.strokeStyle = Color.random().toString();\r\n                    item.symbol = symbol1;\r\n                    item.low = stat.min + i * (stat.max - stat.min) / breaks;\r\n                    item.high = stat.min + (i + 1) * (stat.max - stat.min) / breaks;\r\n                    item.label = item.low + \" - \" + item.high;\r\n                    this._items.push(item);\r\n                    break;\r\n                case GeometryType.Polyline:\r\n                    const symbol2 = new SimpleLineSymbol();\r\n                    symbol2.strokeStyle = Color.random().toString();\r\n                    item.symbol = symbol2;\r\n                    item.low = stat.min + i * (stat.max - stat.min) / breaks;\r\n                    item.high = stat.min + (i + 1) * (stat.max - stat.min) / breaks;\r\n                    item.label = item.low + \" - \" + item.high;\r\n                    this._items.push(item);\r\n                    break;\r\n                case GeometryType.Polygon:\r\n                    const symbol3 = new SimpleFillSymbol();\r\n                    symbol3.fillStyle = Color.random().toString();\r\n                    symbol3.strokeStyle = Color.random().toString();\r\n                    item.symbol = symbol3;\r\n                    item.low = stat.min + i * (stat.max - stat.min) / breaks;\r\n                    item.high = stat.min + (i + 1) * (stat.max - stat.min) / breaks;\r\n                    item.label = item.low + \" - \" + item.high;\r\n                    this._items.push(item);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","export class Renderer {\r\n}\r\n","export class SimpleRenderer {\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { Color } from \"../util/color\";\r\nexport class Symbol {\r\n    constructor() {\r\n        this.lineWidth = 1;\r\n        this.strokeStyle = \"#ff0000\"; //#ff0000\r\n        this.fillStyle = \"#ff000088\"; //#ff0000\r\n    }\r\n}\r\nexport class PointSymbol extends Symbol {\r\n    //渲染\r\n    draw(ctx, screenX, screenY) { }\r\n    //判断点是否在符号范围内\r\n    contain(anchorX, anchorY, screenX, screenY) { return false; }\r\n}\r\nexport class LineSymbol extends Symbol {\r\n    draw(ctx, screen) { }\r\n}\r\nexport class FillSymbol extends Symbol {\r\n    draw(ctx, screen) { }\r\n}\r\nexport class SimplePointSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        //circle\r\n        this.radius = 6;\r\n    }\r\n    draw(ctx, screenX, screenY) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n    contain(anchorX, anchorY, screenX, screenY) {\r\n        return Math.sqrt((anchorX - screenX) * (anchorX - screenX) + (anchorY - screenY) * (anchorY - screenY)) <= this.radius;\r\n    }\r\n}\r\nexport class SimpleLineSymbol extends LineSymbol {\r\n    draw(ctx, screen) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep lineWidth\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.beginPath();\r\n        screen.forEach((point, index) => {\r\n            const screenX = point[0], screenY = point[1];\r\n            if (index === 0) {\r\n                ctx.moveTo(screenX, screenY);\r\n            }\r\n            else {\r\n                ctx.lineTo(screenX, screenY);\r\n            }\r\n        });\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}\r\nexport class SimpleFillSymbol extends Symbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.lineWidth = 2;\r\n    }\r\n    draw(ctx, screen) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep lineWidth\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        //TODO:  exceeding the maximum extent(bound), best way is overlap by extent. find out: maximum is [-PI*R, PI*R]??\r\n        ctx.beginPath();\r\n        screen.forEach(ring => {\r\n            ring.forEach((point, index) => {\r\n                const screenX = point[0], screenY = point[1];\r\n                if (index === 0) {\r\n                    ctx.moveTo(screenX, screenY);\r\n                }\r\n                else {\r\n                    ctx.lineTo(screenX, screenY);\r\n                }\r\n            });\r\n        });\r\n        ctx.closePath();\r\n        ctx.fill(\"evenodd\");\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}\r\nexport class SimpleMarkerSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.width = 16;\r\n        this.height = 16;\r\n        this.offsetX = 8;\r\n        this.offsetY = 8;\r\n    }\r\n    get loaded() {\r\n        return this._loaded;\r\n    }\r\n    load() {\r\n        return new Promise((resolve, reject) => {\r\n            let img = new Image();\r\n            img.onload = () => {\r\n                createImageBitmap(img).then(icon => {\r\n                    this.icon = icon;\r\n                    this._loaded = true;\r\n                    resolve(icon);\r\n                }, err => reject(err));\r\n            };\r\n            img.onerror = reject;\r\n            img.src = this.url;\r\n        });\r\n    }\r\n    draw(ctx, screenX, screenY) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.loaded)\r\n                yield this.load();\r\n            if (this.icon) {\r\n                ctx.save();\r\n                const matrix = ctx.getTransform();\r\n                //keep size\r\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n                ctx.drawImage(this.icon, screenX + this.offsetX, screenY + this.offsetY, this.width, this.height);\r\n                ctx.restore();\r\n            }\r\n        });\r\n    }\r\n    contain(anchorX, anchorY, screenX, screenY) {\r\n        return screenX >= (anchorX + this.offsetX) && screenX <= (anchorX + this.offsetX + this.width) && screenY >= (anchorY + this.offsetY) && screenY <= (anchorY + this.offsetY + this.height);\r\n    }\r\n}\r\nexport class ClusterSymbol extends PointSymbol {\r\n    constructor(count) {\r\n        super();\r\n        this._count = 2;\r\n        this.radius = 10;\r\n        this.strokeStyle = \"#ffffff\"; //#ff0000\r\n        this.outerFillStyle = \"#ffffff\"; //#ff0000\r\n        this.fontColor = \"#ffffff\";\r\n        this.fontFamily = \"YaHei\";\r\n        this.fontWeight = \"Bold\";\r\n        this._count = count;\r\n    }\r\n    get text() {\r\n        return this._count <= 99 ? this._count.toString() : \"99+\";\r\n    }\r\n    get inner() {\r\n        return this._count <= 15 ? this.radius + this._count : this.radius + 15;\r\n    }\r\n    get outer() {\r\n        return this.inner + 4;\r\n    }\r\n    get fontSize() {\r\n        if (this._count < 10) {\r\n            return 12;\r\n        }\r\n        else if (this._count >= 10 && this._count < 30) {\r\n            return 14;\r\n        }\r\n        else if (this._count >= 30 && this._count < 50) {\r\n            return 16;\r\n        }\r\n        else if (this._count >= 30 && this._count < 50) {\r\n            return 18;\r\n        }\r\n        else if (this._count > 50) {\r\n            return 20;\r\n        }\r\n    }\r\n    get innerFillStyle() {\r\n        //const colors = Color.ramp(new Color(0, 255, 0), new Color(255,0,0), 16);\r\n        //const colors = Color.ramp(new Color(22,198,227), new Color(255, 0, 255), 16);\r\n        const colors = Color.ramp(new Color(25, 202, 173), new Color(244, 96, 108), 16);\r\n        return colors[this._count <= 15 ? this._count : 15].toString();\r\n    }\r\n    draw(ctx, screenX, screenY) {\r\n        ctx.save();\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.outerFillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        //keep size\r\n        ctx.arc(screenX, screenY, this.outer, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.fillStyle = this.innerFillStyle;\r\n        ctx.beginPath(); //Start path\r\n        //keep size\r\n        ctx.arc(screenX, screenY, this.inner, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.fillStyle = this.fontColor;\r\n        ctx.font = this.fontSize + \"px/1 \" + this.fontFamily + \" \" + this.fontWeight;\r\n        ctx.fillText(this.text, screenX, screenY);\r\n        ctx.restore();\r\n    }\r\n}\r\n","//边界类，用在包络矩形，以及投影的平面坐标边界\r\nexport class Bound {\r\n    constructor(xmin, ymin, xmax, ymax) {\r\n        //+1代表 x方向为自西向东，-1则反之\r\n        this._xscale = 1;\r\n        //+1代表 y方向为自北向南，-1则反之\r\n        this._yscale = 1;\r\n        this._xmin = Math.min(xmin, xmax);\r\n        this._ymin = Math.min(ymin, ymax);\r\n        this._xmax = Math.max(xmin, xmax);\r\n        this._ymax = Math.max(ymin, ymax);\r\n        this._xscale = xmin <= xmax ? 1 : -1;\r\n        this._yscale = ymin <= ymax ? 1 : -1;\r\n    }\r\n    get xmin() {\r\n        return this._xmin;\r\n    }\r\n    get ymin() {\r\n        return this._ymin;\r\n    }\r\n    get xmax() {\r\n        return this._xmax;\r\n    }\r\n    get ymax() {\r\n        return this._ymax;\r\n    }\r\n    get xscale() {\r\n        return this._xscale;\r\n    }\r\n    get yscale() {\r\n        return this._yscale;\r\n    }\r\n    getCenter() {\r\n        return [(this._xmin + this._xmax) / 2, (this._ymin + this._ymax) / 2];\r\n    }\r\n    //是否交叉叠盖\r\n    intersect(bound) {\r\n        return (bound.xmax >= this._xmin) && (bound.xmin <= this._xmax) && (bound.ymax >= this._ymin) && (bound.ymin <= this._ymax);\r\n    }\r\n    scale(s) {\r\n        this._xmin = this._xmin - (s - 1) * (this._xmax - this._xmin) / 2;\r\n        this._xmax = this._xmax + (s - 1) * (this._xmax - this._xmin) / 2;\r\n        this._ymin = this._ymin - (s - 1) * (this._ymax - this._ymin) / 2;\r\n        this._ymax = this._ymax + (s - 1) * (this._ymax - this._ymin) / 2;\r\n    }\r\n}\r\n","export class Color {\r\n    constructor(r, g, b, a = 1) {\r\n        this.a = 1;\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n    }\r\n    toString() {\r\n        return \"rgba(\" + this.r + \",\" + this.g + \",\" + this.b + \",\" + this.a + \")\";\r\n    }\r\n    static fromHex(hex) {\r\n        let reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/;\r\n        hex = hex.toLowerCase();\r\n        if (hex && reg.test(hex)) {\r\n            //处理三位的颜色值\r\n            if (hex.length === 4) {\r\n                var sColorNew = \"#\";\r\n                for (var i = 1; i < 4; i += 1) {\r\n                    sColorNew += hex.slice(i, i + 1).concat(hex.slice(i, i + 1));\r\n                }\r\n                hex = sColorNew;\r\n            }\r\n            //处理六位的颜色值\r\n            if (hex.length === 4) {\r\n                hex += \"ff\";\r\n            }\r\n            let sColorChange = [];\r\n            for (let i = 1; i < 9; i += 2) {\r\n                sColorChange.push(parseInt(\"0x\" + hex.slice(i, i + 2)));\r\n            }\r\n            return new Color(sColorChange[0], sColorChange[1], sColorChange[2], sColorChange[3] / 255);\r\n        }\r\n    }\r\n    static ramp(start, end, count = 10) {\r\n        const colors = [];\r\n        for (let i = 0; i < count; i += 1) {\r\n            colors.push(new Color((end.r - start.r) * i / count + start.r, (end.g - start.g) * i / count + start.g, (end.b - start.b) * i / count + start.b, (end.a - start.a) * i / count + start.a));\r\n        }\r\n        return colors;\r\n    }\r\n    static random() {\r\n        return new Color(Math.random() * 255, Math.random() * 255, Math.random() * 255);\r\n    }\r\n}\r\n","import {\r\n    Map,\r\n    Point,\r\n    Polyline,\r\n    SimpleFillSymbol,\r\n    FeatureClass,\r\n    FeatureLayer,\r\n    SimpleRenderer,\r\n    CategoryRenderer,\r\n    CategoryRendererItem,\r\n    Field,\r\n    FieldType,\r\n    Graphic, SimpleMarkerSymbol, Feature, LatLngType, GCJ02\r\n} from \"../dist\";\r\n\r\nwindow.load = () => {\r\n    const amap = new AMap.Map(\"amap\", {\r\n        fadeOnZoom: false,\r\n        navigationMode: 'classic',\r\n        optimizePanAnimation: false,\r\n        animateEnable: false,\r\n        dragEnable: false,\r\n        zoomEnable: false,\r\n        resizeEnable: true,\r\n        doubleClickZoom: false,\r\n        keyboardEnable: false,\r\n        scrollWheel: false,\r\n        expandZoomRange: true,\r\n        zooms: [1, 20],\r\n        mapStyle: 'normal',\r\n        features: ['road', 'point', 'bg'],\r\n        viewMode: '2D'\r\n    });\r\n\r\n    const map = new Map(\"foo\");\r\n    map.on(\"extent\", (event) => {\r\n        amap.setZoomAndCenter(event.zoom, event.center);\r\n    });\r\n\r\n    const req = new XMLHttpRequest();\r\n    req.onload = (event) => {\r\n        const featureClass = new FeatureClass();\r\n        featureClass.loadGeoJSON(JSON.parse(req.responseText));\r\n        const featureLayer = new FeatureLayer();\r\n        featureLayer.featureClass = featureClass;\r\n        const renderer = new SimpleRenderer();\r\n        featureLayer.cluster = true;\r\n        featureLayer.renderer = renderer;\r\n        featureLayer.zoom = [13, 20];\r\n        map.addLayer(featureLayer);\r\n\r\n        map.setView([109.519, 18.271], 13);\r\n    };\r\n    req.open(\"GET\", \"assets/geojson/junction.json\", true);\r\n    req.send(null);\r\n\r\n}\r\n\r\n//cause typescript tsc forget js suffix for geometry.js"],"sourceRoot":""}